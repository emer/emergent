// Code generated by "core generate -add-types"; DO NOT EDIT.

package env

import (
	"cogentcore.org/core/types"
)

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.Counter", IDName: "counter", Doc: "Counter maintains a current and previous counter value,\nand a Max value with methods to manage.", Fields: []types.Field{{Name: "Cur", Doc: "Cur is the current counter value."}, {Name: "Prev", Doc: "Prev previous counter value, prior to last Incr() call (init to -1)"}, {Name: "Changed", Doc: "Changed reports if it changed on the last Step() call or not."}, {Name: "Max", Doc: "Max is the maximum counter value, above which the counter will reset back to 0.\nOnly used if > 0."}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.CurPrev", IDName: "cur-prev", Doc: "CurPrev manages current and previous values for basic data types.", Fields: []types.Field{{Name: "Cur"}, {Name: "Prev"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.CurPrevString", IDName: "cur-prev-string"})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.Env", IDName: "env", Doc: "Env defines an interface for environments, which determine the nature and\nsequence of States as inputs to a model. Action responses from the model\ncan also drive state evolution.\n\nState is comprised of one or more Elements, each of which consists of an\ntensor.Values chunk of values that can be obtained by the model.\nThe Step method advances the Env state.\n\nThe standard String() string fmt.Stringer method must be defined to return\na string description of the current environment state, e.g., as a TrialName.\nA Label() string method must be defined to return the Name of the environment,\nwhich is typically the Mode of usage (Train vs. Test).\n\nTypically each specific implementation of this Env interface will have\nmultiple parameters etc that can be modified to control env behavior:\nall of this is paradigm-specific and outside the scope of this basic interface.", Directives: []types.Directive{{Tool: "go", Directive: "generate", Args: []string{"core", "generate", "-add-types"}}}, Methods: []types.Method{{Name: "Init", Doc: "Init initializes the environment for a given run of the model.\nIt is best if the Env has its own random seed and random sequence\ngenerator (e.g., lab/randx), and sets a new random seed for each run.\nIt may also implement different parameterizations for different runs\n(e.g., between-subject manipulations).\nSee Step() for important info about state of env after Init\nbut prior to first Step() call.", Args: []string{"run"}}, {Name: "Step", Doc: "Step generates the next step of environment state.\nThis is the main API for how the model interacts with the environment.\nThe env should update all other levels of state internally over\nrepeated calls to the Step method.\nIf there are no further inputs available, it returns false (most envs\ntypically only return true and just continue running as long as needed).\n\nThe Env thus always reflects the _current_ state of things, and this\ncall increments that current state, such that subsequent calls to\nState() will return this current state.\n\nThis implies that the state just after Init and prior to first Step\ncall should be an _initialized_ state that then allows the first Step\ncall to establish the proper _first_ state. Typically this means that\none or more counters will be set to -1 during Init and then get incremented\nto 0 on the first Step call.", Returns: []string{"bool"}}, {Name: "State", Doc: "State returns the given element's worth of tensor data from the environment\nbased on the current state of the env, as a function of having called Step().\nIf no output is available on that element, then nil is returned.\nThe returned tensor must be treated as read-only as it likely points to original\nsource data: please make a copy before modifying (e.g., Clone() methdod).", Args: []string{"element"}, Returns: []string{"Values"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.Envs", IDName: "envs", Doc: "Envs is a map of environments organized according\nto the evaluation mode string (recommended key value)"})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.FixedTable", IDName: "fixed-table", Doc: "FixedTable is a basic Env that manages patterns from a [table.Table], with\neither sequential or permuted random ordering, with a Trial counter\nto record progress and iterations through the table.\nUse [table.NewView] to provide a unique indexed view of a shared table.", Fields: []types.Field{{Name: "Name", Doc: "name of this environment, usually Train vs. Test."}, {Name: "Table", Doc: "Table has the set of patterns to output.\nThe indexes are used for the *sequential* view so you can easily\nsort / split / filter the patterns to be presented using this view.\nThis adds the random permuted Order on top of those if !sequential."}, {Name: "Sequential", Doc: "present items from the table in sequential order (i.e., according to\nthe indexed view on the Table)?  otherwise permuted random order."}, {Name: "Order", Doc: "permuted order of items to present if not sequential.\nupdated every time through the list."}, {Name: "Trial", Doc: "current ordinal item in Table. if Sequential then = row number in table,\notherwise is index in Order list that then gives row number in Table."}, {Name: "TrialName", Doc: "if Table has a Name column, this is the contents of that."}, {Name: "GroupName", Doc: "if Table has a Group column, this is contents of that."}, {Name: "NameCol", Doc: "name of the Name column -- defaults to 'Name'."}, {Name: "GroupCol", Doc: "name of the Group column -- defaults to 'Group'."}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.FreqTable", IDName: "freq-table", Doc: "FreqTable is an Env that manages patterns from an table.Table with frequency\ninformation so that items are presented according to their associated frequencies\nwhich are effectively probabilities of presenting any given input -- must have\na Freq column with these numbers in the table (actual col name in FreqCol).\nEither sequential or permuted random ordering is supported, with std Trial / Epoch\nTimeScale counters to record progress and iterations through the table.\nIt also records the outer loop of Run as provided by the model.\nIt uses an IndexView indexed view of the Table, so a single shared table\ncan be used across different environments, with each having its own unique view.", Fields: []types.Field{{Name: "Name", Doc: "name of this environment"}, {Name: "Table", Doc: "Table has the set of patterns to output.\nThe indexes are used for the *sequential* view so you can easily\nsort / split / filter the patterns to be presented using this view.\nThis adds the random permuted Order on top of those if !sequential."}, {Name: "NSamples", Doc: "number of samples to use in constructing the list of items to present according to frequency -- number per epoch ~ NSamples * Freq -- see RandSamp option"}, {Name: "RandSamp", Doc: "if true, use random sampling of items NSamples times according to given Freq probability value -- otherwise just directly add NSamples * Freq items to the list"}, {Name: "Sequential", Doc: "present items from the table in sequential order (i.e., according to the indexed view on the Table)?  otherwise permuted random order.  All repetitions of given item will be sequential if Sequential"}, {Name: "Order", Doc: "list of items to present, with repetitions -- updated every time through the list"}, {Name: "Trial", Doc: "current ordinal item in Table -- if Sequential then = row number in table, otherwise is index in Order list that then gives row number in Table"}, {Name: "TrialName", Doc: "if Table has a Name column, this is the contents of that"}, {Name: "GroupName", Doc: "if Table has a Group column, this is contents of that"}, {Name: "NameCol", Doc: "name of the Name column -- defaults to 'Name'"}, {Name: "GroupCol", Doc: "name of the Group column -- defaults to 'Group'"}, {Name: "FreqCol", Doc: "name of the Freq column -- defaults to 'Freq'"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.MPIFixedTable", IDName: "mpi-fixed-table", Doc: "MPIFixedTable is an MPI-enabled version of the [FixedTable], which is\na basic Env that manages patterns from a [table.Table[, with\neither sequential or permuted random ordering, and a Trial counter to\nrecord iterations through the table.\nUse [table.NewView] to provide a unique indexed view of a shared table.\nThe MPI version distributes trials across MPI procs, in the Order list.\nIt is ESSENTIAL that the number of trials (rows) in Table is\nevenly divisible by number of MPI procs!\nIf all nodes start with the same seed, it should remain synchronized.", Fields: []types.Field{{Name: "Name", Doc: "name of this environment"}, {Name: "Table", Doc: "Table has the set of patterns to output.\nThe indexes are used for the *sequential* view so you can easily\nsort / split / filter the patterns to be presented using this view.\nThis adds the random permuted Order on top of those if !sequential."}, {Name: "Sequential", Doc: "present items from the table in sequential order (i.e., according to the indexed view on the Table)?  otherwise permuted random order"}, {Name: "Order", Doc: "permuted order of items to present if not sequential -- updated every time through the list"}, {Name: "Trial", Doc: "current ordinal item in Table -- if Sequential then = row number in table, otherwise is index in Order list that then gives row number in Table"}, {Name: "TrialName", Doc: "if Table has a Name column, this is the contents of that"}, {Name: "GroupName", Doc: "if Table has a Group column, this is contents of that"}, {Name: "NameCol", Doc: "name of the Name column -- defaults to 'Name'"}, {Name: "GroupCol", Doc: "name of the Group column -- defaults to 'Group'"}, {Name: "TrialSt", Doc: "for MPI, trial we start each epoch on, as index into Order"}, {Name: "TrialEd", Doc: "for MPI, trial number we end each epoch before (i.e., when ctr gets to Ed, restarts)"}}})
