// Copyright (c) 2024, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package params

import (
	"fmt"
)

// Search represents one parameter search element, applying given selector
// to objects of given type, using float32 values generated by given function.
type Search[T Styler] struct {
	// Sel is the selector for what to apply the parameters to,
	// using standard css selector syntax:
	//	- .Example applies to anything with a Class tag of 'Example'
	//	- #Example applies to anything with a Name of 'Example'
	//	- Example with no prefix or blank selector always applies as the presumed Type.
	Sel string

	// Set function applies given parameter value to the given object
	// of the target type.
	Set func(v T, val float32)

	// Vals is a function that generates values to search over. This is
	// typically called once at the start of the entire search process to get
	// a list of values that are cached, to determine the total number of search
	// jobs required, and then it is called again when this parameter is at the
	// top of the list to be searched, so that new values can potentially be
	// generated.
	Vals func() []float32

	cached []float32
}

// Apply checks if Sel selector applies to this object according to
// (.Class, #Name, Type) using the Styler interface, and returns
// false if it does not. If it does apply, then the given value
// is passed to the Set function on the object, and true is returned.
func (ps *Search[T]) Apply(obj T, val float32) bool {
	if !SelMatch(ps.Sel, obj) {
		return false
	}
	ps.Set(obj, val)
	return true
}

// Value returns the parameter value at given value index.
// Returns false if the value index is invalid.
func (ps *Search[T]) Value(valIndex int) (bool, float32) {
	vals := ps.Values()
	if valIndex >= len(vals) {
		return false, 0
	}
	val := vals[valIndex]
	return true, val
}

// Values returns the search values, using cached values if already set,
// and returning [Search.CacheValues] otherwise.
func (ps *Search[T]) Values() []float32 {
	if ps.cached != nil {
		return ps.cached
	}
	return ps.CacheValues()
}

// CacheValues calls the Vals function and caches the resulting values
// for later use. This can be called for dynamic searches to update the
// current values relative to any initial cached values, if the search is
// dynamic and depends on other state. Returns the updated cached values.
func (ps *Search[T]) CacheValues() []float32 {
	ps.cached = ps.Vals()
	return ps.cached
}

// JobString returns a string that identifies a param search job
// for given parameter index and value, for this item.
func (ps *Search[T]) JobString(paramIndex int, val float32) string {
	return fmt.Sprintf("Search %d: %s=%g", paramIndex, ps.Sel, val)
}

// Searches is a list of [Search] elements, representing an entire
// parameter search process, where multiple parameters with multiple
// values per parameter are searched, typically in parallel across
// independent sim run jobs. Thus, you first get the total number of
// params via the [Searches.NumParams] method, and then launch jobs
// for each of these param indexes, which applies that param.
type Searches[T Styler] []*Search[T]

// NumParams returns the total number of parameter values to search.
// This calls the Vals function to generate initial search values.
func (sr Searches[T]) NumParams() int {
	n := 0
	for _, ps := range sr {
		n += len(ps.Values())
	}
	return n
}

// SearchAtIndex returns the [Search] element at given parameter
// index in range [0..NumParams), and the value index within that search.
func (sr Searches[T]) SearchAtIndex(paramIndex int) (*Search[T], int) {
	n := 0
	for _, ps := range sr {
		sn := len(ps.Values())
		if paramIndex >= n && paramIndex < n+sn {
			return ps, paramIndex - n
		}
		n += sn
	}
	return nil, -1
}

// SearchValue returns [Search] and value for parameter at given
// param index within searches, returning error for invalid index.
// Also returns string descriptor for parameter.
func (sr Searches[T]) SearchValue(paramIndex int) (*Search[T], float32, string, error) {
	ps, valIndex := sr.SearchAtIndex(paramIndex)
	if ps == nil {
		return ps, 0, "", fmt.Errorf("No param search found for param index: %d", paramIndex)
	}
	ok, val := ps.Value(valIndex)
	if !ok {
		return ps, 0, "", fmt.Errorf("Param value index out of range: %d, for Sel: %s", valIndex, ps.Sel)
	}
	lbl := ps.JobString(paramIndex, val)
	return ps, val, lbl, nil
}
