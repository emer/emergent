// Code generated by "core generate -add-types"; DO NOT EDIT.

package emer

import (
	"cogentcore.org/core/types"
)

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Layer", IDName: "layer", Doc: "Layer defines the minimal interface for neural network layers,\nnecessary to support the visualization (NetView), I/O,\nand parameter setting functionality provided by emergent.\nMost of the standard expected functionality is defined in the\nLayerBase struct, and this interface only has methods that must be\nimplemented specifically for a given algorithmic implementation.", Methods: []types.Method{{Name: "AsEmer", Doc: "AsEmer returns the layer as an *emer.LayerBase,\nto access base functionality.", Returns: []string{"LayerBase"}}, {Name: "Label", Doc: "Label satisfies the core.Labeler interface for getting\nthe name of objects generically. Use to access Name via interface.", Returns: []string{"string"}}, {Name: "TypeName", Doc: "TypeName is the type or category of layer, defined\nby the algorithm (and usually set by an enum).", Returns: []string{"string"}}, {Name: "TypeNumber", Doc: "TypeNumber is the numerical value for the type or category\nof layer, defined by the algorithm (and usually set by an enum).", Returns: []string{"int"}}, {Name: "UnitVarIndex", Doc: "UnitVarIndex returns the index of given variable within\nthe Neuron, according to *this layer's* UnitVarNames() list\n(using a map to lookup index), or -1 and error message if\nnot found.", Args: []string{"varNm"}, Returns: []string{"int", "error"}}, {Name: "UnitValue1D", Doc: "UnitValue1D returns value of given variable index on given unit,\nusing 1-dimensional index, and a data parallel index di,\nfor networks capable of processing multiple input patterns\nin parallel. Returns NaN on invalid index.\nThis is the core unit var access method used by other methods,\nso it is the only one that needs to be updated for derived layer types.", Args: []string{"varIndex", "idx", "di"}, Returns: []string{"float32"}}, {Name: "VarRange", Doc: "VarRange returns the min / max values for given variable", Args: []string{"varNm"}, Returns: []string{"min", "max", "err"}}, {Name: "NumRecvPaths", Doc: "NumRecvPaths returns the number of receiving pathways.", Returns: []string{"int"}}, {Name: "RecvPath", Doc: "RecvPath returns a specific receiving pathway.", Args: []string{"idx"}, Returns: []string{"Path"}}, {Name: "NumSendPaths", Doc: "NumSendPaths returns the number of sending pathways.", Returns: []string{"int"}}, {Name: "SendPath", Doc: "SendPath returns a specific sending pathway.", Args: []string{"idx"}, Returns: []string{"Path"}}, {Name: "RecvPathValues", Doc: "RecvPathValues fills in values of given synapse variable name,\nfor pathway from given sending layer and neuron 1D index,\nfor all receiving neurons in this layer,\ninto given float32 slice (only resized if not big enough).\npathType is the string representation of the path type;\nused if non-empty, useful when there are multiple pathways\nbetween two layers.\nReturns error on invalid var name.\nIf the receiving neuron is not connected to the given sending\nlayer or neuron then the value is set to math32.NaN().\nReturns error on invalid var name or lack of recv path\n(vals always set to nan on path err).", Args: []string{"vals", "varNm", "sendLay", "sendIndex1D", "pathType"}, Returns: []string{"error"}}, {Name: "SendPathValues", Doc: "SendPathValues fills in values of given synapse variable name,\nfor pathway into given receiving layer and neuron 1D index,\nfor all sending neurons in this layer,\ninto given float32 slice (only resized if not big enough).\npathType is the string representation of the path type -- used if non-empty,\nuseful when there are multiple pathways between two layers.\nReturns error on invalid var name.\nIf the sending neuron is not connected to the given receiving layer or neuron\nthen the value is set to math32.NaN().\nReturns error on invalid var name or lack of recv path (vals always set to nan on path err).", Args: []string{"vals", "varNm", "recvLay", "recvIndex1D", "pathType"}, Returns: []string{"error"}}, {Name: "ParamsString", Doc: "ParamsString returns a listing of all parameters in the Layer and\npathways within the layer. If nonDefault is true, only report those\nnot at their default values.", Args: []string{"nonDefault"}, Returns: []string{"string"}}, {Name: "WriteWeightsJSON", Doc: "WriteWeightsJSON writes the weights from this layer from the\nreceiver-side perspective in a JSON text format.", Args: []string{"w", "depth"}}, {Name: "SetWeights", Doc: "SetWeights sets the weights for this layer from weights.Layer\ndecoded values", Args: []string{"lw"}, Returns: []string{"error"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.LayerBase", IDName: "layer-base", Doc: "LayerBase defines the basic shared data for neural network layers,\nused for managing the structural elements of a network,\nand for visualization, I/O, etc.\nNothing algorithm-specific is implemented here", Fields: []types.Field{{Name: "EmerLayer", Doc: "EmerLayer provides access to the emer.Layer interface\nmethods for functions defined in the LayerBase type.\nMust set this with a pointer to the actual instance\nwhen created, using InitLayer function."}, {Name: "Name", Doc: "Name of the layer, which must be unique within the network.\nLayers are typically accessed directly by name, via a map."}, {Name: "Class", Doc: "Class is for applying parameter styles across multiple layers\nthat all get the same parameters.  This can be space separated\nwith multple classes."}, {Name: "Doc", Doc: "Doc contains documentation about the layer.\nThis is displayed in a tooltip in the network view."}, {Name: "Off", Doc: "Off turns off the layer, removing from all computations.\nThis provides a convenient way to dynamically test for\nthe contributions of the layer, for example."}, {Name: "Shape", Doc: "Shape of the layer, either 2D or 4D.  Although spatial topology\nis not relevant to all algorithms, the 2D shape is important for\nefficiently visualizing large numbers of units / neurons.\n4D layers have 2D Pools of units embedded within a larger 2D\norganization of such pools.  This is used for max-pooling or\npooled inhibition at a finer-grained level, and biologically\ncorresopnds to hypercolumns in the cortex for example.\nOrder is outer-to-inner (row major), so Y then X for 2D;\n4D: Y-X unit pools then Y-X neurons within pools."}, {Name: "Pos", Doc: "Pos specifies the relative spatial relationship to another\nlayer, which determines positioning.  Every layer except one\n\"anchor\" layer should be positioned relative to another,\ne.g., RightOf, Above, etc.  This provides robust positioning\nin the face of layer size changes etc.\nLayers are arranged in X-Y planes, stacked vertically along the Z axis."}, {Name: "Index", Doc: "Index is a 0..n-1 index of the position of the layer within\nthe list of layers in the network."}, {Name: "SampleIndexes", Doc: "SampleIndexes are the current set of \"sample\" unit indexes,\nwhich are a smaller subset of units that represent the behavior\nof the layer, for computationally intensive statistics and displays\n(e.g., PCA, ActRF, NetView rasters), when the layer is large.\nIf none have been set, then all units are used.\nSee utility function CenterPoolIndexes that returns indexes of\nunits in the central pools of a 4D layer."}, {Name: "SampleShape", Doc: "SampleShape is the shape to use for the subset of sample\nunit indexes, in terms of an array of dimensions.\nSee Shape for more info.\nLayers that set SampleIndexes should also set this,\notherwise a 1D array of len SampleIndexes will be used.\nSee utility function CenterPoolShape that returns shape of\nunits in the central pools of a 4D layer."}, {Name: "MetaData", Doc: "optional metadata that is saved in network weights files,\ne.g., can indicate number of epochs that were trained,\nor any other information about this network that would be useful to save."}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.VarCategory", IDName: "var-category", Doc: "VarCategory represents one category of unit, synapse variables.", Fields: []types.Field{{Name: "Cat", Doc: "Category name."}, {Name: "Doc", Doc: "Documentation of the category, used as a tooltip."}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Network", IDName: "network", Doc: "Network defines the minimal interface for a neural network,\nused for managing the structural elements of a network,\nand for visualization, I/O, etc.\nMost of the standard expected functionality is defined in the\nNetworkBase struct, and this interface only has methods that must be\nimplemented specifically for a given algorithmic implementation.", Methods: []types.Method{{Name: "AsEmer", Doc: "AsEmer returns the network as an *emer.NetworkBase,\nto access base functionality.", Returns: []string{"NetworkBase"}}, {Name: "Label", Doc: "Label satisfies the core.Labeler interface for getting\nthe name of objects generically.", Returns: []string{"string"}}, {Name: "NumLayers", Doc: "NumLayers returns the number of layers in the network.", Returns: []string{"int"}}, {Name: "EmerLayer", Doc: "EmerLayer returns layer as emer.Layer interface at given index.\nDoes not do extra bounds checking.", Args: []string{"idx"}, Returns: []string{"Layer"}}, {Name: "MaxParallelData", Doc: "MaxParallelData returns the maximum number of data inputs that can be\nprocessed in parallel by the network.\nThe NetView supports display of up to this many data elements.", Returns: []string{"int"}}, {Name: "NParallelData", Doc: "NParallelData returns the current number of data inputs currently being\nprocessed in parallel by the network.\nLogging supports recording each of these where appropriate.", Returns: []string{"int"}}, {Name: "Defaults", Doc: "Defaults sets default parameter values for everything in the Network."}, {Name: "UpdateParams", Doc: "UpdateParams() updates parameter values for all Network parameters,\nbased on any other params that might have changed."}, {Name: "KeyLayerParams", Doc: "KeyLayerParams returns a listing for all layers in the network,\nof the most important layer-level params (specific to each algorithm).", Returns: []string{"string"}}, {Name: "KeyPathParams", Doc: "KeyPathParams returns a listing for all Recv pathways in the network,\nof the most important pathway-level params (specific to each algorithm).", Returns: []string{"string"}}, {Name: "UnitVarNames", Doc: "UnitVarNames returns a list of variable names available on\nthe units in this network.\nThis list determines what is shown in the NetView\n(and the order of vars list).\nNot all layers need to support all variables,\nbut must safely return math32.NaN() for unsupported ones.\nThis is typically a global list so do not modify!", Returns: []string{"[]string"}}, {Name: "UnitVarProps", Doc: "UnitVarProps returns a map of unit variable properties,\nwith the key being the name of the variable,\nand the value gives a space-separated list of\ngo-tag-style properties for that variable.\nThe NetView recognizes the following properties:\n\t- range:\"##\" = +- range around 0 for default display scaling\n\t- min:\"##\" max:\"##\" = min, max display range\n\t- auto-scale:\"+\" or \"-\" = use automatic scaling instead of fixed range or not.\n\t- zeroctr:\"+\" or \"-\" = control whether zero-centering is used\n\t- desc:\"txt\" tooltip description of the variable\n\t- cat:\"cat\" variable category, for category tabs", Returns: []string{"map[string]string"}}, {Name: "VarCategories", Doc: "VarCategories is a list of unit & synapse variable categories,\nwhich organizes the variables into separate tabs in the network view.\nUsing categories results in a more compact display and makes it easier\nto find variables.\nSet the 'cat' property in the UnitVarProps, SynVarProps for each variable.\nIf no categories returned, the default is Unit, Wt.", Returns: []string{"VarCategory"}}, {Name: "SynVarNames", Doc: "SynVarNames returns the names of all the variables\non the synapses in this network.\nThis list determines what is shown in the NetView\n(and the order of vars list).\nNot all pathways need to support all variables,\nbut must safely return math32.NaN() for\nunsupported ones.\nThis is typically a global list so do not modify!", Returns: []string{"[]string"}}, {Name: "SynVarProps", Doc: "SynVarProps returns a map of synapse variable properties,\nwith the key being the name of the variable,\nand the value gives a space-separated list of\ngo-tag-style properties for that variable.\nThe NetView recognizes the following properties:\nrange:\"##\" = +- range around 0 for default display scaling\nmin:\"##\" max:\"##\" = min, max display range\nauto-scale:\"+\" or \"-\" = use automatic scaling instead of fixed range or not.\nzeroctr:\"+\" or \"-\" = control whether zero-centering is used\nNote: this is typically a global list so do not modify!", Returns: []string{"map[string]string"}}, {Name: "ReadWeightsJSON", Doc: "ReadWeightsJSON reads network weights from the receiver-side perspective\nin a JSON text format. Reads entire file into a temporary weights.Weights\nstructure that is then passed to Layers etc using SetWeights method.\nCall the NetworkBase version followed by any post-load updates.", Args: []string{"r"}, Returns: []string{"error"}}, {Name: "WriteWeightsJSON", Doc: "WriteWeightsJSON writes the weights from this network\nfrom the receiver-side perspective in a JSON text format.\nCall the NetworkBase version after pre-load updates.", Args: []string{"w"}, Returns: []string{"error"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.NetworkBase", IDName: "network-base", Doc: "NetworkBase defines the basic data for a neural network,\nused for managing the structural elements of a network,\nand for visualization, I/O, etc.", Methods: []types.Method{{Name: "SaveWeightsJSON", Doc: "SaveWeightsJSON saves network weights (and any other state that adapts with learning)\nto a JSON-formatted file.  If filename has .gz extension, then file is gzip compressed.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "OpenWeightsJSON", Doc: "OpenWeightsJSON opens network weights (and any other state that adapts with learning)\nfrom a JSON-formatted file.  If filename has .gz extension, then file is gzip uncompressed.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}}, Fields: []types.Field{{Name: "EmerNetwork", Doc: "EmerNetwork provides access to the emer.Network interface\nmethods for functions defined in the NetworkBase type.\nMust set this with a pointer to the actual instance\nwhen created, using InitNetwork function."}, {Name: "Name", Doc: "overall name of network, which helps discriminate if there are multiple."}, {Name: "WeightsFile", Doc: "filename of last weights file loaded or saved."}, {Name: "LayerNameMap", Doc: "map of name to layers, for EmerLayerByName methods"}, {Name: "MinPos", Doc: "minimum display position in network"}, {Name: "MaxPos", Doc: "maximum display position in network"}, {Name: "MetaData", Doc: "optional metadata that is saved in network weights files,\ne.g., can indicate number of epochs that were trained,\nor any other information about this network that would be useful to save."}, {Name: "Rand", Doc: "random number generator for the network.\nall random calls must use this.\nSet seed here for weight initialization values."}, {Name: "RandSeed", Doc: "Random seed to be set at the start of configuring\nthe network and initializing the weights.\nSet this to get a different set of weights."}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Path", IDName: "path", Doc: "Path defines the minimal interface for a pathway\nwhich connects two layers, using a specific Pattern\nof connectivity, and with its own set of parameters.\nThis supports visualization (NetView), I/O,\nand parameter setting functionality provided by emergent.\nMost of the standard expected functionality is defined in the\nPathBase struct, and this interface only has methods that must be\nimplemented specifically for a given algorithmic implementation,", Methods: []types.Method{{Name: "AsEmer", Doc: "AsEmer returns the path as an *emer.PathBase,\nto access base functionality.", Returns: []string{"PathBase"}}, {Name: "Label", Doc: "Label satisfies the core.Labeler interface for getting\nthe name of objects generically. Use to access Name via interface.", Returns: []string{"string"}}, {Name: "TypeName", Doc: "TypeName is the type or category of path, defined\nby the algorithm (and usually set by an enum).", Returns: []string{"string"}}, {Name: "TypeNumber", Doc: "TypeNumber is the numerical value for the type or category\nof path, defined by the algorithm (and usually set by an enum).", Returns: []string{"int"}}, {Name: "SendLayer", Doc: "SendLayer returns the sending layer for this pathway,\nas an emer.Layer interface.  The actual Path implmenetation\ncan use a Send field with the actual Layer struct type.", Returns: []string{"Layer"}}, {Name: "RecvLayer", Doc: "RecvLayer returns the receiving layer for this pathway,\nas an emer.Layer interface.  The actual Path implmenetation\ncan use a Recv field with the actual Layer struct type.", Returns: []string{"Layer"}}, {Name: "NumSyns", Doc: "NumSyns returns the number of synapses for this path.\nThis is the max idx for SynValue1D and the number\nof vals set by SynValues.", Returns: []string{"int"}}, {Name: "SynIndex", Doc: "SynIndex returns the index of the synapse between given send, recv unit indexes\n(1D, flat indexes). Returns -1 if synapse not found between these two neurons.\nThis requires searching within connections for receiving unit (a bit slow).", Args: []string{"sidx", "ridx"}, Returns: []string{"int"}}, {Name: "SynVarNames", Doc: "SynVarNames returns the names of all the variables on the synapse\nThis is typically a global list so do not modify!", Returns: []string{"[]string"}}, {Name: "SynVarNum", Doc: "SynVarNum returns the number of synapse-level variables\nfor this paths.  This is needed for extending indexes in derived types.", Returns: []string{"int"}}, {Name: "SynVarIndex", Doc: "SynVarIndex returns the index of given variable within the synapse,\naccording to *this path's* SynVarNames() list (using a map to lookup index),\nor -1 and error message if not found.", Args: []string{"varNm"}, Returns: []string{"int", "error"}}, {Name: "SynValues", Doc: "SynValues sets values of given variable name for each synapse,\nusing the natural ordering of the synapses (sender based for Axon),\ninto given float32 slice (only resized if not big enough).\nReturns error on invalid var name.", Args: []string{"vals", "varNm"}, Returns: []string{"error"}}, {Name: "SynValue1D", Doc: "SynValue1D returns value of given variable index\n(from SynVarIndex) on given SynIndex.\nReturns NaN on invalid index.\nThis is the core synapse var access method used by other methods,\nso it is the only one that needs to be updated for derived types.", Args: []string{"varIndex", "synIndex"}, Returns: []string{"float32"}}, {Name: "ParamsString", Doc: "ParamsString returns a listing of all parameters in the pathway.\nIf nonDefault is true, only report those not at their default values.", Args: []string{"nonDefault"}, Returns: []string{"string"}}, {Name: "WriteWeightsJSON", Doc: "WriteWeightsJSON writes the weights from this pathway\nfrom the receiver-side perspective in a JSON text format.", Args: []string{"w", "depth"}}, {Name: "SetWeights", Doc: "SetWeights sets the weights for this pathway from weights.Path\ndecoded values", Args: []string{"pw"}, Returns: []string{"error"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.PathBase", IDName: "path-base", Doc: "PathBase defines the basic shared data for a pathway\nwhich connects two layers, using a specific Pattern\nof connectivity, and with its own set of parameters.\nThe same struct token is added to the Recv and Send\nlayer path lists,", Fields: []types.Field{{Name: "EmerPath", Doc: "EmerPath provides access to the emer.Path interface\nmethods for functions defined in the PathBase type.\nMust set this with a pointer to the actual instance\nwhen created, using InitPath function."}, {Name: "Name", Doc: "Name of the path, which can be automatically set to\nSendLayer().Name + \"To\" + RecvLayer().Name via\nSetStandardName method."}, {Name: "Class", Doc: "Class is for applying parameter styles across multiple paths\nthat all get the same parameters. This can be space separated\nwith multple classes."}, {Name: "Doc", Doc: "Doc contains documentation about the pathway.\nThis is displayed in a tooltip in the network view."}, {Name: "Notes", Doc: "can record notes about this pathway here."}, {Name: "Pattern", Doc: "Pattern specifies the pattern of connectivity\nfor interconnecting the sending and receiving layers."}, {Name: "Off", Doc: "Off inactivates this pathway, allowing for easy experimentation."}}})
